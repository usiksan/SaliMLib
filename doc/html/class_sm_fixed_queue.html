<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SaliMLib: SmFixedQueue&lt; Item, queueSize &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SaliMLib
   &#160;<span id="projectnumber">0.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_sm_fixed_queue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SmFixedQueue&lt; Item, queueSize &gt; Class Template Reference<div class="ingroups"><a class="el" href="group___c_plus_plus_part.html">SaliMLib core library</a> &raquo; <a class="el" href="group__fixed_containers.html">SaliMLib Containers with fixed size</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="class_sm_fixed_queue.html" title="The SmFixedQueue Templace class for building queue with fixed size. ">SmFixedQueue</a> Templace class for building queue with fixed size.  
 <a href="class_sm_fixed_queue.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_sali_m_core_8h_source.html">SaliMCore.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af305c1aefe05b317eabd45bd9df96dcf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sm_fixed_queue.html#af305c1aefe05b317eabd45bd9df96dcf">itemCount</a> () const</td></tr>
<tr class="memdesc:af305c1aefe05b317eabd45bd9df96dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">itemCount Returns item count in the queue (Common fixedContainer interface)  <a href="#af305c1aefe05b317eabd45bd9df96dcf">More...</a><br /></td></tr>
<tr class="separator:af305c1aefe05b317eabd45bd9df96dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca023bb7ecdf388fa230d4a74e8300b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sm_fixed_queue.html#acca023bb7ecdf388fa230d4a74e8300b">emptyCount</a> () const</td></tr>
<tr class="memdesc:acca023bb7ecdf388fa230d4a74e8300b"><td class="mdescLeft">&#160;</td><td class="mdescRight">emptyCount Returns count of free places in the queue (Common fixedContainer interface)  <a href="#acca023bb7ecdf388fa230d4a74e8300b">More...</a><br /></td></tr>
<tr class="separator:acca023bb7ecdf388fa230d4a74e8300b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7da52e1200fa5777151b38d393d183c"><td class="memItemLeft" align="right" valign="top"><a id="ad7da52e1200fa5777151b38d393d183c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sm_fixed_queue.html#ad7da52e1200fa5777151b38d393d183c">clear</a> ()</td></tr>
<tr class="memdesc:ad7da52e1200fa5777151b38d393d183c"><td class="mdescLeft">&#160;</td><td class="mdescRight">clear Clear queue contents (Common fixedContainer interface) <br /></td></tr>
<tr class="separator:ad7da52e1200fa5777151b38d393d183c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5436bfe399afa5a332bc609d757dcbad"><td class="memItemLeft" align="right" valign="top">Item &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sm_fixed_queue.html#a5436bfe399afa5a332bc609d757dcbad">at</a> (int index) const</td></tr>
<tr class="memdesc:a5436bfe399afa5a332bc609d757dcbad"><td class="mdescLeft">&#160;</td><td class="mdescRight">at Return item at index beginning from mHead. index value must not exceed elements count (Common fixedContainer interface)  <a href="#a5436bfe399afa5a332bc609d757dcbad">More...</a><br /></td></tr>
<tr class="separator:a5436bfe399afa5a332bc609d757dcbad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bfa2d864309ca5b72778ad547d3c9c0"><td class="memItemLeft" align="right" valign="top"><a id="a2bfa2d864309ca5b72778ad547d3c9c0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sm_fixed_queue.html#a2bfa2d864309ca5b72778ad547d3c9c0">waitItem</a> ()</td></tr>
<tr class="memdesc:a2bfa2d864309ca5b72778ad547d3c9c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">waitItem Waits until there is at least one element in the container (Common fixedContainer interface) <br /></td></tr>
<tr class="separator:a2bfa2d864309ca5b72778ad547d3c9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d459795bd4927d54a2c650309bd820"><td class="memItemLeft" align="right" valign="top"><a id="a53d459795bd4927d54a2c650309bd820"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sm_fixed_queue.html#a53d459795bd4927d54a2c650309bd820">waitItemCount</a> (int count)</td></tr>
<tr class="memdesc:a53d459795bd4927d54a2c650309bd820"><td class="mdescLeft">&#160;</td><td class="mdescRight">waitItem Waits until there is at least count elements in the container (Common fixedContainer interface) <br /></td></tr>
<tr class="separator:a53d459795bd4927d54a2c650309bd820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614b9118b713937a7cab23e5bc876615"><td class="memItemLeft" align="right" valign="top"><a id="a614b9118b713937a7cab23e5bc876615"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sm_fixed_queue.html#a614b9118b713937a7cab23e5bc876615">waitEmpty</a> ()</td></tr>
<tr class="memdesc:a614b9118b713937a7cab23e5bc876615"><td class="mdescLeft">&#160;</td><td class="mdescRight">waitEmpty Waits until there is space for at least one element (Common fixedContainer interface) <br /></td></tr>
<tr class="separator:a614b9118b713937a7cab23e5bc876615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ee64dba183dbc8b31a9caad4b63301"><td class="memItemLeft" align="right" valign="top"><a id="a46ee64dba183dbc8b31a9caad4b63301"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sm_fixed_queue.html#a46ee64dba183dbc8b31a9caad4b63301">waitEmptyCount</a> (int count)</td></tr>
<tr class="memdesc:a46ee64dba183dbc8b31a9caad4b63301"><td class="mdescLeft">&#160;</td><td class="mdescRight">waitEmptyCount Waits until there is space for at least count elements (Common fixedContainer interface) <br /></td></tr>
<tr class="separator:a46ee64dba183dbc8b31a9caad4b63301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ddabb7c5945194f4d844fbf840f18a5"><td class="memItemLeft" align="right" valign="top"><a id="a1ddabb7c5945194f4d844fbf840f18a5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sm_fixed_queue.html#a1ddabb7c5945194f4d844fbf840f18a5">waitContinueItem</a> ()</td></tr>
<tr class="memdesc:a1ddabb7c5945194f4d844fbf840f18a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">waitContinueItemWaits until there is at least one element as continued block in the container <br /></td></tr>
<tr class="separator:a1ddabb7c5945194f4d844fbf840f18a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2e69180792fc676237674f9f67ecc6"><td class="memItemLeft" align="right" valign="top">Item &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sm_fixed_queue.html#a1b2e69180792fc676237674f9f67ecc6">head</a> () const</td></tr>
<tr class="memdesc:a1b2e69180792fc676237674f9f67ecc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">head Return head element  <a href="#a1b2e69180792fc676237674f9f67ecc6">More...</a><br /></td></tr>
<tr class="separator:a1b2e69180792fc676237674f9f67ecc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc08ab9376ffd0cd6e0912a1e038bcef"><td class="memItemLeft" align="right" valign="top">Item&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sm_fixed_queue.html#abc08ab9376ffd0cd6e0912a1e038bcef">deque</a> ()</td></tr>
<tr class="memdesc:abc08ab9376ffd0cd6e0912a1e038bcef"><td class="mdescLeft">&#160;</td><td class="mdescRight">deque Retrieves an item from the queue  <a href="#abc08ab9376ffd0cd6e0912a1e038bcef">More...</a><br /></td></tr>
<tr class="separator:abc08ab9376ffd0cd6e0912a1e038bcef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa6c2a68b1d45a9a18f8f5da3aa7c20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sm_fixed_queue.html#abaa6c2a68b1d45a9a18f8f5da3aa7c20">enque</a> (Item item)</td></tr>
<tr class="memdesc:abaa6c2a68b1d45a9a18f8f5da3aa7c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">enque Puts an item in the queue  <a href="#abaa6c2a68b1d45a9a18f8f5da3aa7c20">More...</a><br /></td></tr>
<tr class="separator:abaa6c2a68b1d45a9a18f8f5da3aa7c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe867629bb051358a4c7b5d46f5f8934"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sm_fixed_queue.html#afe867629bb051358a4c7b5d46f5f8934">continueCount</a> () const</td></tr>
<tr class="memdesc:afe867629bb051358a4c7b5d46f5f8934"><td class="mdescLeft">&#160;</td><td class="mdescRight">continueCount Returns the size of a continuous section  <a href="#afe867629bb051358a4c7b5d46f5f8934">More...</a><br /></td></tr>
<tr class="separator:afe867629bb051358a4c7b5d46f5f8934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ef201f1c679b25f7669283800b1129"><td class="memItemLeft" align="right" valign="top">Item *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sm_fixed_queue.html#ae4ef201f1c679b25f7669283800b1129">continueBuffer</a> ()</td></tr>
<tr class="memdesc:ae4ef201f1c679b25f7669283800b1129"><td class="mdescLeft">&#160;</td><td class="mdescRight">continueBuffer Returns pointer to a continuous section  <a href="#ae4ef201f1c679b25f7669283800b1129">More...</a><br /></td></tr>
<tr class="separator:ae4ef201f1c679b25f7669283800b1129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59983ad03b9dec4a8a521a6e0860245e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sm_fixed_queue.html#a59983ad03b9dec4a8a521a6e0860245e">continueDeque</a> (int count)</td></tr>
<tr class="memdesc:a59983ad03b9dec4a8a521a6e0860245e"><td class="mdescLeft">&#160;</td><td class="mdescRight">continueDeque Remove block of count elements from queue  <a href="#a59983ad03b9dec4a8a521a6e0860245e">More...</a><br /></td></tr>
<tr class="separator:a59983ad03b9dec4a8a521a6e0860245e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Item, int queueSize&gt;<br />
class SmFixedQueue&lt; Item, queueSize &gt;</h3>

<p>The <a class="el" href="class_sm_fixed_queue.html" title="The SmFixedQueue Templace class for building queue with fixed size. ">SmFixedQueue</a> Templace class for building queue with fixed size. </p>
<p>The most widely used container in embedded systems is a queue. Support for queues in SaliMLib is carried out using the template <a class="el" href="class_sm_fixed_queue.html" title="The SmFixedQueue Templace class for building queue with fixed size. ">SmFixedQueue</a>. In addition to traditional extraction and deletion operations, the queue provides access to the maximum contiguous section. This access is convenient for implementing algorithms for sending data blocks.</p>
<div class="fragment"><div class="line"><span class="comment">//UART structure from ST library</span></div><div class="line">UART_HandleTypeDef huart3;</div><div class="line"></div><div class="line"><span class="keyword">using</span> QueueChar1000 = <a class="code" href="class_sm_fixed_queue.html">SmFixedQueue&lt;char,1000&gt;</a>;</div><div class="line"></div><div class="line">QueueChar1000 uartQueue;</div><div class="line"></div><div class="line"><span class="comment">//The task of transmitting characters from the queue in blocks using DMA</span></div><div class="line"><span class="keywordtype">void</span> uartSenderTask( <span class="keywordtype">void</span>* )</div><div class="line">  {</div><div class="line">  <span class="keywordflow">while</span>(<span class="keyword">true</span>) {</div><div class="line">    <span class="comment">//Waiting for characters in the queue</span></div><div class="line">    uartQueue.<a class="code" href="class_sm_fixed_queue.html#a1ddabb7c5945194f4d844fbf840f18a5">waitContinueItem</a>();</div><div class="line">    <span class="keywordtype">int</span> count = uartQueue.continueCount();</div><div class="line">    <span class="comment">//Initiate a dma exchange</span></div><div class="line">    HAL_UART_Transmit_DMA( &amp;huart3, (uint8_t*) uartQueue.continueBuffer(), count );</div><div class="line">    <span class="comment">//Wait for the exchange to complete</span></div><div class="line">    smWait&lt;UART_HandleTypeDef&gt;( &amp;huart3, [] ( UART_HandleTypeDef *huart ) -&gt; <span class="keywordtype">bool</span> { <span class="keywordflow">return</span> HAL_UART_GetState(huart) == HAL_UART_STATE_READY; });</div><div class="line">    <span class="comment">//Exchange completed, remove the transferred characters from the queue</span></div><div class="line">    uartQueue.continueDeque(count);</div><div class="line">    }</div><div class="line">  }</div></div><!-- fragment --><p>The queue provides quick insertion into the tail and quick removal from the head. This time is fixed and does not depend on the queue size. The queue provides constant time for accessing any items located in the queue.</p>
<p>The queue can also work for communication between the interrupt handler and the main program. For example, if a character is interrupted by uart, it can be added to the queue, and extracted and analyzed in the main queue.</p>
<dl class="section warning"><dt>Warning</dt><dd>Important! When Queuing in interrupts, you must manually check the availability of space in the queue to avoid switching tasks built into these functions. </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a5436bfe399afa5a332bc609d757dcbad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5436bfe399afa5a332bc609d757dcbad">&#9670;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Item , int queueSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Item&amp; <a class="el" href="class_sm_fixed_queue.html">SmFixedQueue</a>&lt; Item, queueSize &gt;::at </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>at Return item at index beginning from mHead. index value must not exceed elements count (Common fixedContainer interface) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>index is value from 0 to count. When index eq 0 then return head element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Element with index </dd></dl>

</div>
</div>
<a id="ae4ef201f1c679b25f7669283800b1129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ef201f1c679b25f7669283800b1129">&#9670;&nbsp;</a></span>continueBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Item , int queueSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Item* <a class="el" href="class_sm_fixed_queue.html">SmFixedQueue</a>&lt; Item, queueSize &gt;::continueBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>continueBuffer Returns pointer to a continuous section </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a continuous section </dd></dl>

</div>
</div>
<a id="afe867629bb051358a4c7b5d46f5f8934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe867629bb051358a4c7b5d46f5f8934">&#9670;&nbsp;</a></span>continueCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Item , int queueSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_sm_fixed_queue.html">SmFixedQueue</a>&lt; Item, queueSize &gt;::continueCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>continueCount Returns the size of a continuous section </p>
<dl class="section return"><dt>Returns</dt><dd>Size of a continuous section </dd></dl>

</div>
</div>
<a id="a59983ad03b9dec4a8a521a6e0860245e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59983ad03b9dec4a8a521a6e0860245e">&#9670;&nbsp;</a></span>continueDeque()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Item , int queueSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_sm_fixed_queue.html">SmFixedQueue</a>&lt; Item, queueSize &gt;::continueDeque </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>continueDeque Remove block of count elements from queue </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Count of removed elements </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc08ab9376ffd0cd6e0912a1e038bcef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc08ab9376ffd0cd6e0912a1e038bcef">&#9670;&nbsp;</a></span>deque()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Item , int queueSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Item <a class="el" href="class_sm_fixed_queue.html">SmFixedQueue</a>&lt; Item, queueSize &gt;::deque </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>deque Retrieves an item from the queue </p>
<dl class="section return"><dt>Returns</dt><dd>Retrived item </dd></dl>

</div>
</div>
<a id="acca023bb7ecdf388fa230d4a74e8300b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acca023bb7ecdf388fa230d4a74e8300b">&#9670;&nbsp;</a></span>emptyCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Item , int queueSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_sm_fixed_queue.html">SmFixedQueue</a>&lt; Item, queueSize &gt;::emptyCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>emptyCount Returns count of free places in the queue (Common fixedContainer interface) </p>
<dl class="section return"><dt>Returns</dt><dd>Count of free places </dd></dl>

</div>
</div>
<a id="abaa6c2a68b1d45a9a18f8f5da3aa7c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa6c2a68b1d45a9a18f8f5da3aa7c20">&#9670;&nbsp;</a></span>enque()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Item , int queueSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_sm_fixed_queue.html">SmFixedQueue</a>&lt; Item, queueSize &gt;::enque </td>
          <td>(</td>
          <td class="paramtype">Item&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>enque Puts an item in the queue </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>Item to put </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b2e69180792fc676237674f9f67ecc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b2e69180792fc676237674f9f67ecc6">&#9670;&nbsp;</a></span>head()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Item , int queueSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Item&amp; <a class="el" href="class_sm_fixed_queue.html">SmFixedQueue</a>&lt; Item, queueSize &gt;::head </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>head Return head element </p>
<dl class="section return"><dt>Returns</dt><dd>Element at head </dd></dl>

</div>
</div>
<a id="af305c1aefe05b317eabd45bd9df96dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af305c1aefe05b317eabd45bd9df96dcf">&#9670;&nbsp;</a></span>itemCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Item , int queueSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_sm_fixed_queue.html">SmFixedQueue</a>&lt; Item, queueSize &gt;::itemCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>itemCount Returns item count in the queue (Common fixedContainer interface) </p>
<dl class="section return"><dt>Returns</dt><dd>Item count in the queue </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/asibilev/work/SaliMLib/source/<a class="el" href="_sali_m_core_8h_source.html">SaliMCore.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
